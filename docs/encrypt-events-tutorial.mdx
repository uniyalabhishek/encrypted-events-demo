---
title: Encrypting Event Payloads on Oasis Sapphire
description: Two practical patterns to keep event contents private while preserving on-chain discoverability.
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!-- markdownlint-disable MD025 MD033 -->

# Encrypting Event Payloads on Sapphire

On Ethereum, **all event data is public**. On Sapphire (confidential EVM), you can keep the **event payload encrypted** while the event itself stays indexable and triggerable.

This guide shows two minimal, production-ready patterns (both are in the example repo):

- **A â€” Pass a key in the (encrypted) tx** *(default)*:
  Generate a 32â€‘byte symmetric key offâ€‘chain, pass it to the contract **via an encrypted transaction**, and the contract emits ciphertext.

- **B â€” Derive the key onâ€‘chain (ECDH)** *(alternate)*:
  Exchange Curve25519 public keys, derive a session key onâ€‘chain via X25519, then emit ciphertext.

> â±ï¸ **10 minutes** Â· ğŸ§° Node 18+, Docker (Localnet), Git Â· ğŸ§ª The repo also includes unit tests and a oneâ€‘shot E2E script.

> âš ï¸ **Testnet is not production.** Confidentiality is **not guaranteed** on Testnet. Use Localnet for development and Sapphire Mainnet for production.

---

## Why encrypt event payloads?

Sapphire can fully hide **calldata** and **state**, but **logs are public by design** so indexers and infra can function. Encrypting just the **payload** gives you:

- âœ… **Searchable/triggerable** events (by topics)
- âœ… **Confidential** contents (ciphertext in `data`)
- âœ… Minimal onâ€‘chain footprint (emit only what you need)

---

## Quick Start

```bash title="Prerequisites"
# Node 18+, Docker (for Localnet), Git
```

### Clone & Install

```bash
git clone https://github.com/oasisprotocol/encrypted-events-demo.git
cd encrypted-events-demo
npm install
```

### Start Sapphire Localnet

```bash
docker run -it -p8544:8544 -p8545:8545 -p8546:8546 ghcr.io/oasisprotocol/sapphire-localnet
# On Apple Silicon, add: --platform linux/amd64  (if the image lacks arm64)
```

---

## Run the Demo

<Tabs>
  <TabItem value="a" label="A â€” Key in the tx (default)" default>

> âš ï¸ **Only on Sapphire.** Passing a raw key in calldata is safe **only** on Sapphire networks because the Sapphire wrappers **encrypt calls/transactions**. Do **not** use this pattern on nonâ€‘Sapphire chains.

The Hardhat Sapphire plugin **encrypts transactions/calls automatically** on Sapphire networks, so passing a raw key in calldata is safe.

```bash
# 1) Deploy the simple variant
npx hardhat deploy --network sapphire_localnet
# copy the printed address to $ADDR (this is the CONTRACT address, not a tx hash)

# 2) Emit an encrypted event (prints the symmetric key)
#    Tip: provide --key to reuse the same key across emit & listen.
npx hardhat emit --network sapphire_localnet \
  --contract $ADDR --message "secret ğŸš€" [--key <HEX32>]
# âš ï¸ **DEMO ONLY: Do NOT log secret keys in production.**

# 3) Decrypt a past tx by hash
npx hardhat decrypt --network sapphire_localnet \
  --tx <TX_HASH> --key <PRINTED_OR_PROVIDED_KEY> [--aad]

# 4) ğŸ”Š  Live: listen & decrypt as events arrive (stays open until Ctrlâ€‘C)
npx hardhat listen --network sapphire_localnet \
  --contract $ADDR --key <PRINTED_OR_PROVIDED_KEY> [--aad]
```

  </TabItem>
  <TabItem value="b" label="B â€” Onâ€‘chain ECDH (alternate)">

```bash
# 1) Deploy the ECDH variant (prints the contractâ€™s Curve25519 public key)
npx hardhat deploy-ecdh --network sapphire_localnet
# copy the printed address to $ADDR

# 2) Emit
#    Tip: provide --secret to reuse the same caller secret across emit & listen.
npx hardhat emit-ecdh --network sapphire_localnet \
  --contract $ADDR --message "secret ğŸš€" [--secret <HEX32>] [--aad]
# âš ï¸ **DEMO ONLY: Do NOT log secret keys in production.**

# 3) ğŸ”Š  Live: listen & decrypt (derives the same shared key from --secret)
npx hardhat listen-ecdh --network sapphire_localnet \
  --contract $ADDR --secret <HEX32> [--aad]
```

  </TabItem>
</Tabs>

---

## How it works (at a glance)

| Piece                 | Code (on-chain) / Library (off-chain)                      |
| --------------------- | ---------------------------------------------------------- |
| **Nonce**             | `bytes32 n = bytes32(Sapphire.randomBytes(32, bytes("")));`       |
| **Encrypt**           | `bytes c = Sapphire.encrypt(key, n, bytes(message), aad);` |
| **Emit**              | `emit Encrypted(n, c);`                                    |
| **Decrypt offâ€‘chain** | `@oasisprotocol/deoxysii` (`AEAD`, `NonceSize = 15`)       |

> **Nonce size:** Deoxysâ€‘II uses a **120â€‘bit (15 bytes)** nonce. We store 32 bytes on chain and use only the first 15 bytes during decryption.

### Key handling patterns

* **Default (wrapperâ€‘encrypted tx):** Provide `bytes32 key` in calldata. Safe because the Sapphire Hardhat plugin **encrypts transactions** on Sapphire networks.
* **ECDH onâ€‘chain:** The contract holds a Curve25519 **secret key** in encrypted state, the caller sends a **public key**; both sides derive the same 32â€‘byte key via X25519.

```sol title="ECDH-style symmetric key derivation on-chain"
(Sapphire.Curve25519PublicKey pk, Sapphire.Curve25519SecretKey sk) =
  Sapphire.generateCurve25519KeyPair("");
bytes32 key = Sapphire.deriveSymmetricKey(callerPublicKey, sk);
```

> â„¹ï¸ **KDF note (ECDH):** Offâ€‘chain, derive the Deoxysâ€‘II key from the X25519 shared secret using **HMACâ€‘SHA512/256** with label `"MRAE_Box_Deoxys-II-256-128"` before creating `new AEAD(key)`. This mirrors Sapphireâ€™s onâ€‘chain derivation.

### Bind ciphertexts with AAD (recommended)

AAD prevents accepting ciphertexts out of context. Bind to `msg.sender`:

```sol title="Solidity: include AAD"
bytes32 nonce = bytes32(Sapphire.randomBytes(32, bytes("")));
bytes memory aad = abi.encodePacked(msg.sender); // 20 bytes
bytes memory cipher = Sapphire.encrypt(key, nonce, bytes(message), aad);
emit Encrypted(nonce, cipher);
```

```ts title="TypeScript: use the same AAD when decrypting"
const aad = ethers.getBytes(tx.from);   // 20 bytes to match abi.encodePacked(address)
const plain = aead.decrypt(
  ethers.getBytes(nonce).slice(0, NonceSize),   // first 15 bytes
  ethers.getBytes(ciphertext),
  aad
);
```

#### AAD caveat: relayers & forwarders

`msg.sender` (onâ€‘chain) equals `tx.from` (offâ€‘chain) **only** for direct EOA â†’ contract calls. If a relayer, forwarder (e.g., EIPâ€‘2771), or another contract calls your contract, `msg.sender â‰  tx.from`, and offâ€‘chain decryption with `ethers.getBytes(tx.from)` will fail **by design**.

**Alternatives:**

* **Bind to context (relayerâ€‘friendly):** use `abi.encodePacked(block.chainid, address(this))` as AAD. Offâ€‘chain, replicate the same packed bytes exactly. This prevents crossâ€‘chain/contract replay without depending on the callerâ€™s identity.
* **Expose & bind to sender explicitly:** add an `address sender` param in the event (public) and include that **same address** in AAD. Easier to reconstruct offâ€‘chain, but publicly reveals the sender.
* **(Advanced)** If you truly need caller identity across relayers, consider your forwarderâ€™s semantics (e.g., EIPâ€‘2771) and bind AAD to the **original signer** as recovered by the forwarder.

---

## ROFL integration (pattern)

A ROFL container can subscribe to your contractâ€™s `Encrypted` events, then decrypt:

1. **Subscribe** by contract and event signature.
2. **Derive the key**:

   * Pattern **A**: retrieve the symmetric key out of band (e.g., injected secret corresponding to the submitter).
   * Pattern **B**: compute `x25519.scalarMult(callerSecret, contractPublic)` using the **callerâ€™s secret** provided to the container.
3. **Fetch AAD** (if used): for `msg.sender`, read `tx.from` for direct EOA calls **only**; otherwise use your chosen AAD scheme (see caveat above).
4. **Decrypt** with Deoxysâ€‘II (`Nonce = first 15 bytes of the stored 32â€‘byte nonce`).
5. **Act** on the plaintext (no extra storage read necessary).

> Keep the event payload **small** (e.g., an envelope or offâ€‘chain reference) to minimize gas.

---

## Best practices

* **Never reuse `(key, nonce)`**. Always randomize `nonce`. (Deoxysâ€‘II is misuseâ€‘resistant, but reusing the *exact same* nonce with the same key is still unsafe.)
* Prefer **AAD** to bind context; choose an AAD scheme compatible with your calling model (see **AAD caveat**).
* For ECDH, prefer **ephemeral caller keys** to reduce linkability (or derive perâ€‘message keys from `(ECDH, nonce)` via a KDF).
* **Do not log secrets** (symmetric keys or Curve25519 secrets) in production.
* **Events are permanent**â€”emit only what you can keep confidential longâ€‘term.
* **Testnet is not production**; confidentiality is not guaranteed there.
* **Indexed nonce.** The event uses `bytes32 indexed nonce` for efficient filtering.
* **Pass the right parameter.** `--contract` must be the **contract address** (0xâ€¦), not a transaction hash.

---

## Testnet / Mainnet

```bash
cp .env.example .env      # paste your 0xâ€‘prefixed private key
npx hardhat deploy --network sapphire_testnet
npx hardhat deploy-ecdh --network sapphire_testnet
# Use the same emit/listen/decrypt tasks as on Localnet
```

---

## FAQ

<details>
<summary>Can I decrypt logs as they arrive?</summary>
Yes. Use `npx hardhat listen â€¦` (wrapper) or `npx hardhat listen-ecdh â€¦` (ECDH). They stay open until you press **Ctrlâ€‘C**.
</details>

<details>
<summary>Why store 32 bytes of nonce if only 15 are used?</summary>
Deoxysâ€‘II defines a 120â€‘bit nonce. Generating and storing 32 bytes on-chain reduces bias and gives you room for future derivations, while you still pass only the first 15 bytes to the AEAD.
</details>

<details>
<summary>Is it safe if the ECDH shared key is reused across messages?</summary>
Yes, **as long as each encryption uses a unique nonce**. Still, ephemeral caller keys are recommended; alternatively, derive a per-message key from `(ECDH, nonce)` via a KDF.
</details>
