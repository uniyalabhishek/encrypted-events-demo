---
title: Encrypting Event Payloads on Oasis Sapphire
description: Two practical patterns to keep event contents private while preserving on-chain discoverability.
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!-- markdownlint-disable MD025 MD033 -->

# Encrypting Event Payloads on Sapphire

On Ethereum, **all event data is public**. On Sapphire (confidential EVM), you can keep the **event payload encrypted** while the event itself stays indexable and triggerable.

This guide shows two minimal, production-ready patterns (both are in the example repo):

* **A ‚Äî Pass a key in the (encrypted) tx** *(default)*:
  Generate a 32‚Äëbyte symmetric key off‚Äëchain, pass it to the contract **via an encrypted transaction**, and the contract emits ciphertext.

* **B ‚Äî Derive the key on‚Äëchain (ECDH)** *(alternate)*:
  Exchange Curve25519 public keys, derive a session key on‚Äëchain via X25519, then emit ciphertext.

> ‚è±Ô∏è **10 minutes** ¬∑ üß∞ Node 18+, Docker (Localnet), Git ¬∑ üß™ Repo includes unit tests and a one‚Äëshot E2E script.

> ‚ö†Ô∏è **Testnet is not production.** Confidentiality is **not guaranteed** on Testnet. Use Localnet for development and Sapphire Mainnet for production.

---

## Why encrypt event payloads?

Sapphire can fully hide **calldata** and **state**, but **logs are public by design** so indexers and infra can function. Encrypting just the **payload** gives you:

* ‚úÖ **Searchable/triggerable** events (by topics)
* ‚úÖ **Confidential** contents (ciphertext in `data`)
* ‚úÖ Minimal on‚Äëchain footprint (emit only what you need)

---

## Quick Start

```bash title="Prerequisites"
# Node 18+, Docker (for Localnet), Git
```

### Clone & Install

```bash
git clone https://github.com/oasisprotocol/encrypted-events-demo.git
cd encrypted-events-demo
npm install

# (Optional) Generate TypeChain types for nicer overloads:
npm run build:types
```

### Start Sapphire Localnet

```bash
docker run -it -p8544-8548:8544-8548 ghcr.io/oasisprotocol/sapphire-localnet
# On Apple Silicon, add: --platform linux/amd64  (if the image lacks arm64)
```

---

## Run the Demo

<Tabs>
  <TabItem value="a" label="A ‚Äî Key in the tx (default)" default>

> ‚ö†Ô∏è **Only on Sapphire.** Passing a raw key in calldata is safe **only** on Sapphire networks because the Sapphire wrappers **encrypt calls/transactions**. Do **not** use this pattern on non‚ÄëSapphire chains.

```bash
# 1) Deploy the simple variant
npx hardhat deploy --network sapphire-localnet
# copy the printed address to $ADDR (this is the CONTRACT address, not a tx hash)

# 2) Emit an encrypted event (prints the symmetric key)
#    Tip: provide --key to reuse the same key across emit & listen.
npx hardhat enc --network sapphire-localnet \
  --action emit --mode key --contract $ADDR \
  --message "secret üöÄ" [--key <HEX32>] [--aad]
# ‚ö†Ô∏è **DEMO ONLY: Do NOT log secret keys in production.**

# 3) Decrypt a past tx by hash
#    (In key mode, --contract is optional; pass it to disambiguate if the tx has multiple logs.)
npx hardhat enc --network sapphire-localnet \
  --action decrypt --mode key [--contract $ADDR] \
  --tx <TX_HASH> --key <PRINTED_OR_PROVIDED_KEY> [--aad]

# 4) üîä  Live: listen & decrypt as events arrive (stays open until Ctrl‚ÄëC)
npx hardhat enc --network sapphire-localnet \
  --action listen --mode key --contract $ADDR \
  --key <PRINTED_OR_PROVIDED_KEY> [--aad]
```

  </TabItem>
  <TabItem value="b" label="B ‚Äî On‚Äëchain ECDH (alternate)">

```bash
# 1) Deploy the ECDH variant (prints the contract‚Äôs Curve25519 public key)
npx hardhat deploy-ecdh --network sapphire-localnet
# copy the printed address to $ADDR

# 2) Emit
#    Tip: provide --secret to reuse the same caller secret across emit & listen.
npx hardhat enc --network sapphire-localnet \
  --action emit --mode ecdh --contract $ADDR \
  --message "secret üöÄ" [--secret <HEX32>] [--aad]
# ‚ö†Ô∏è **DEMO ONLY: Do NOT log secret keys in production.**

# 3) üîä  Live: listen & decrypt (derives the same shared key from --secret)
npx hardhat enc --network sapphire-localnet \
  --action listen --mode ecdh --contract $ADDR \
  --secret <HEX32> [--aad]

# 4) Decrypt a past tx by hash (ECDH ‚Äî needs the contract to fetch its public key)
npx hardhat enc --network sapphire-localnet \
  --action decrypt --mode ecdh --contract $ADDR \
  --tx <TX_HASH> --secret <HEX32> [--aad]
```

  </TabItem>
</Tabs>

---

## How it works (at a glance)

| Piece                 | Code (on-chain) / Library (off-chain)                                            |
| --------------------- | -------------------------------------------------------------------------------- |
| **Nonce**             | `bytes32 n = bytes32(Sapphire.randomBytes(32, bytes("EncryptedEvents:nonce")));` |
| **Encrypt**           | `bytes c = Sapphire.encrypt(key, n, message, aad);` *(message is `bytes`)*       |
| **Emit**              | `emit Encrypted(msg.sender, n, c);`                                              |
| **Decrypt off‚Äëchain** | `@oasisprotocol/deoxysii` (`AEAD`, `NonceSize = 15`)                             |

> **Nonce size:** Deoxys‚ÄëII uses a **120‚Äëbit (15 bytes)** nonce. We store 32 bytes on chain and use only the first 15 bytes during decryption.
> **Gas note:** If you emit a **non‚Äëindexed** `bytes15 nonce` instead of `bytes32`, you save \~136 gas per event (17 bytes √ó 8 gas/byte for log data). We keep `bytes32` for simplicity and future derivations; topic cost is per topic, not per type size.

### Key handling patterns

* **Default (wrapper‚Äëencrypted tx):** Provide `bytes32 key` in calldata. Safe because the Sapphire Hardhat plugin **encrypts transactions** on Sapphire networks.
* **ECDH on‚Äëchain:** The contract holds a Curve25519 **secret key** in encrypted state, the caller sends a **public key**; both sides derive the same 32‚Äëbyte key via X25519.

```sol title="ECDH-style symmetric key derivation on-chain"
(Sapphire.Curve25519PublicKey pk, Sapphire.Curve25519SecretKey sk) =
  Sapphire.generateCurve25519KeyPair("");
bytes32 key = Sapphire.deriveSymmetricKey(callerPublicKey, sk);
```

> ‚ÑπÔ∏è **KDF note (ECDH):** Off‚Äëchain, derive the Deoxys‚ÄëII key from the caller‚Äôs X25519 secret and the contract‚Äôs public key using the **official SDK helper**:
>
> ```ts
> import { mraeDeoxysii } from '@oasisprotocol/client-rt';
> const key = mraeDeoxysii.deriveSymmetricKey(contractPublic, callerSecret);
> const aead = new AEAD(key);
> ```
>
> This mirrors Sapphire‚Äôs on‚Äëchain derivation.

### Bind ciphertexts with AAD (recommended)

AAD prevents accepting ciphertexts out of context. Bind to `msg.sender` **and emit it**:

```sol title="Solidity: include AAD and emit sender"
bytes32 nonce = bytes32(Sapphire.randomBytes(32, bytes("EncryptedEvents:nonce")));
bytes memory aad = abi.encodePacked(msg.sender); // 20 bytes
bytes memory cipher = Sapphire.encrypt(key, nonce, message, aad);
emit Encrypted(msg.sender, nonce, cipher);
```

```ts title="TypeScript: use the emitted sender as AAD"
const sender: string = ev.args[0]; // from the Encrypted event
const aad = ethers.getBytes(sender); // 20 bytes to match abi.encodePacked(address)
const plain = aead.decrypt(
  ethers.getBytes(nonce).slice(0, NonceSize),   // first 15 bytes
  ethers.getBytes(ciphertext),
  aad
);
```

#### AAD caveat: relayers, forwarders & gasless/meta‚Äëtx

`msg.sender` (on‚Äëchain) can differ from `tx.from` when using relayers/forwarders (e.g., EIP‚Äë2771) or meta‚Äëtransactions. **Emitting `sender`** in the event avoids ambiguity: the exact value used for on‚Äëchain AAD is available off‚Äëchain. In meta‚Äëtx flows, the "signer" visible off‚Äëchain may differ‚Äî**`msg.sender` is the on‚Äëchain source of truth**.

**Alternative (relayer‚Äëfriendly) context binding:**

* Solidity:

  ```solidity
  bytes memory aad = abi.encodePacked(block.chainid, address(this));
  ```
* TypeScript (ethers v6):

  ```ts
  const chainId = (await ethers.provider.getNetwork()).chainId;
  const aad = ethers.solidityPacked(["uint256", "address"], [chainId, CONTRACT_ADDRESS]);
  ```

---

## ROFL integration (pattern)

A ROFL container can subscribe to your contract‚Äôs `Encrypted` events, then decrypt:

1. **Subscribe** by contract and event signature.
2. **Derive the key**:

   * Pattern **A**: retrieve the symmetric key out of band (e.g., injected secret corresponding to the submitter).
   * Pattern **B**: compute the same key as on‚Äëchain via `mraeDeoxysii.deriveSymmetricKey(contractPublic, callerSecret)`.
3. **Build AAD**: use the **emitted `sender`** when AAD is used.
4. **Decrypt** with Deoxys‚ÄëII (`Nonce = first 15 bytes of the stored 32‚Äëbyte nonce`).
5. **Act** on the plaintext (no extra storage read necessary).

> Keep the event payload **small** (e.g., an envelope or off‚Äëchain reference) to minimize gas.

---

## Best practices

* **Never reuse `(key, nonce)`**. Always randomize `nonce`.
* Prefer **AAD** for authenticity; emitting the bound context (`sender`) makes decryption robust with relayers.
* For ECDH, prefer **ephemeral caller keys** to reduce linkability (or derive per‚Äëmessage keys from `(ECDH, nonce)` via a KDF).
* **Do not log secrets** (symmetric keys or Curve25519 secrets) in production.
* **Events are permanent**‚Äîemit only what you can keep confidential long‚Äëterm.
* **Testnet is not production**; confidentiality is not guaranteed there.
* **Index wisely.** Indexing a *random nonce* is rarely useful and costs a topic; indexing `sender` is typically more useful. Changing `bytes32 ‚Üí bytes15` does **not** reduce topic cost when indexed (topics are a flat cost).
* **Length leaks size.** If sensitive, **pad** plaintext client‚Äëside to fixed buckets before encrypting.
* **Pass the right parameter.** `--contract` must be the **contract address** (0x‚Ä¶) for all commands except `decrypt --mode key`, where it is optional.

---

## Testnet / Mainnet

```bash
cp .env.example .env      # paste your 0x‚Äëprefixed private key
npx hardhat deploy --network sapphire-testnet
npx hardhat deploy-ecdh --network sapphire-testnet
# Use the same enc commands as on Localnet
```

---

## Unified CLI

```bash
# Emit with a key
npx hardhat enc --network sapphire-localnet --action emit --mode key  --contract $ADDR --message "secret üöÄ" [--key <HEX32>] [--aad]

# Emit with ECDH (prints caller SECRET for demo)
npx hardhat enc --network sapphire-localnet --action emit --mode ecdh --contract $ADDR --message "secret üöÄ" [--secret <HEX32>] [--aad]

# Listen with a key
npx hardhat enc --network sapphire-localnet --action listen --mode key  --contract $ADDR --key <HEX32> [--aad]

# Listen with ECDH (needs caller SECRET)
npx hardhat enc --network sapphire-localnet --action listen --mode ecdh --contract $ADDR --secret <HEX32> [--aad]

# Decrypt a past tx (key) ‚Äì contract optional
npx hardhat enc --network sapphire-localnet --action decrypt --mode key  [--contract $ADDR] --tx <TX_HASH> --key <HEX32> [--aad]

# Decrypt a past tx (ECDH) ‚Äì contract required
npx hardhat enc --network sapphire-localnet --action decrypt --mode ecdh --contract $ADDR --tx <TX_HASH> --secret <HEX32> [--aad]
```

---
