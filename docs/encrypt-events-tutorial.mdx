---
title: Encrypting Event Payloads on Oasis Sapphire
description: Two practical patterns to keep event contents private while preserving on-chain discoverability.
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!-- markdownlint-disable MD025 MD033 -->

# Encrypting Event Payloads on Sapphire

On Ethereum, **all event data is public**. On Sapphire (confidential EVM), you can keep the **event payload encrypted** while the event itself stays indexable and triggerable.

This guide shows two minimal, production-ready patterns (both are in the example repo):

- **A — Pass a key in the (encrypted) tx** *(default)*:
  Generate a 32‑byte symmetric key off‑chain, pass it to the contract **via an encrypted transaction**, and the contract emits ciphertext.

- **B — Derive the key on‑chain (ECDH)** *(alternate)*:
  Exchange Curve25519 public keys, derive a session key on‑chain via X25519, then emit ciphertext.

> ⏱️ **10 minutes** · 🧰 Node 18+, Docker (Localnet), Git · 🧪 The repo also includes unit tests and a one‑shot E2E script.

---

## Why encrypt event payloads?

Sapphire can fully hide **calldata** and **state**, but **logs are public by design** so indexers and infra can function. Encrypting just the **payload** gives you:

- ✅ **Searchable/triggerable** events (by topics)
- ✅ **Confidential** contents (ciphertext in `data`)
- ✅ Minimal on‑chain footprint (emit only what you need)

---

## Quick Start

```bash title="Prerequisites"
# Node 18+, Docker (for Localnet), Git
````

### Clone & Install

```bash
git clone https://github.com/oasisprotocol/encrypted-events-demo.git
cd encrypted-events-demo
npm install
```

### Start Sapphire Localnet

```bash
docker run -it -p8544:8544 -p8545:8545 -p8546:8546 ghcr.io/oasisprotocol/sapphire-localnet
# On Apple Silicon, add: --platform linux/amd64  (if the image lacks arm64)
```

---

## Run the Demo

<Tabs>
  <TabItem value="a" label="A — Key in the tx (default)" default>

The Hardhat Sapphire plugin **encrypts transactions/calls automatically** on Sapphire networks, so passing a raw key in calldata is safe.

```bash
# 1) Deploy the simple variant
npx hardhat deploy --network sapphire_localnet
# copy the printed address to $ADDR

# 2) Emit an encrypted event (prints the symmetric key)
npx hardhat emit --network sapphire_localnet \
  --contract $ADDR --message "secret 🚀"
# ⚠️ **DEMO ONLY: Do NOT log secret keys in production.**

# 3) Decrypt a past tx by hash
npx hardhat decrypt --network sapphire_localnet \
  --tx <TX_HASH> --key <PRINTED_KEY>

# 4) 🔊  Live: listen & decrypt as events arrive
npx hardhat listen --network sapphire_localnet \
  --contract $ADDR --key <PRINTED_KEY>
```

  </TabItem>
  <TabItem value="b" label="B — On‑chain ECDH (alternate)">

```bash
# 1) Deploy the ECDH variant (prints the contract’s Curve25519 public key)
npx hardhat deploy-ecdh --network sapphire_localnet
# copy the printed address to $ADDR

# 2) Emit (generates a fresh caller Curve25519 keypair — DEMO prints the SECRET)
npx hardhat emit-ecdh --network sapphire_localnet \
  --contract $ADDR --message "secret 🚀"
# ⚠️ **DEMO ONLY: Do NOT log secret keys in production.**

# 3) 🔊  Live: listen & decrypt (derives the same shared key from $SK)
npx hardhat listen-ecdh --network sapphire_localnet \
  --contract $ADDR --secret <CALLER_SECRET_HEX>
```

  </TabItem>
</Tabs>

---

## How it works (at a glance)

| Piece                 | Code (on-chain) / Library (off-chain)                       |
| --------------------- | ----------------------------------------------------------- |
| **Nonce**             | `bytes32 n = bytes32(Sapphire.randomBytes(32, ""));`        |
| **Encrypt**           | `bytes c = Sapphire.encrypt(key, n, bytes(message), aad);` |
| **Emit**              | `emit Encrypted(n, c);`                                     |
| **Decrypt off‑chain** | `@oasisprotocol/deoxysii` (`AEAD`, `NonceSize = 15`)        |

> **Nonce size:** Deoxys‑II uses a **120‑bit (15 bytes)** nonce. We store 32 bytes on chain and use only the first 15 bytes during decryption.

### Key handling patterns

- **Default (wrapper‑encrypted tx):** Provide `bytes32 key` in calldata. Safe because the Sapphire Hardhat plugin **encrypts transactions** on Sapphire networks.
- **ECDH on‑chain:** The contract holds a Curve25519 **secret key** in encrypted state, the caller sends a **public key**; both sides derive the same 32‑byte key via X25519.

```sol title="ECDH-style symmetric key derivation on-chain"
(Sapphire.Curve25519PublicKey pk, Sapphire.Curve25519SecretKey sk) =
  Sapphire.generateCurve25519KeyPair("");
bytes32 key = Sapphire.deriveSymmetricKey(callerPublicKey, sk);
```

### Bind ciphertexts with AAD (recommended)

AAD prevents accepting ciphertexts out of context. Bind to `msg.sender`:

```sol title="Solidity: include AAD"
bytes32 nonce = bytes32(Sapphire.randomBytes(32, ""));
bytes memory aad = abi.encodePacked(msg.sender); // 20 bytes
bytes memory cipher = Sapphire.encrypt(key, nonce, abi.encode(message), aad);
emit Encrypted(nonce, cipher);
```

```ts title="TypeScript: use the same AAD when decrypting"
const aad = ethers.getBytes(tx.from);   // 20 bytes to match abi.encodePacked(address)
const plain = aead.decrypt(
  ethers.getBytes(nonce).slice(0, NonceSize),   // first 15 bytes
  ethers.getBytes(ciphertext),
  aad
);
```

---

## ROFL integration (pattern)

A ROFL container can subscribe to your contract’s `Encrypted` events, then decrypt:

1. **Subscribe** by contract and event signature.
2. **Derive the key**:

   - Pattern **A**: retrieve the symmetric key out of band (e.g., injected secret corresponding to the submitter).
   - Pattern **B**: compute `x25519.scalarMult(callerSecret, contractPublic)` using the **caller’s secret** provided to the container.
3. **Fetch AAD** (if used): for `msg.sender`, read `tx.from` for the event’s `transactionHash`.
4. **Decrypt** with Deoxys‑II (`Nonce = first 15 bytes of the stored 32‑byte nonce`).
5. **Act** on the plaintext (no extra storage read necessary).

> Keep the event payload **small** (e.g., an envelope or off‑chain reference) to minimize gas.

---

## Best practices

- **Never reuse `(key, nonce)`**. Always randomize `nonce`.
- Prefer **AAD** (e.g., `msg.sender`) to bind context.
- For ECDH, prefer **ephemeral caller keys** to reduce linkability.
- **Do not log secrets** (symmetric keys or Curve25519 secrets) in production.
- **Events are permanent**—emit only what you can keep confidential long‑term.
- **Testnet is not production**; confidentiality is not guaranteed there.
- Consider indexing the `bytes32 nonce` in the event for more efficient filters.

---

## Testnet / Mainnet

```bash
cp .env.example .env      # paste your 0x‑prefixed private key
npx hardhat deploy --network sapphire_testnet
npx hardhat deploy-ecdh --network sapphire_testnet
# Use the same emit/listen/decrypt tasks as on Localnet
```

---

## FAQ

<details>
<summary>Can I decrypt logs as they arrive?</summary>
Yes. Use `npx hardhat listen …` (wrapper) or `npx hardhat listen-ecdh …` (ECDH). For historical scans, you can query past logs and decrypt each event similarly.
</details>

<details>
<summary>Why store 32 bytes of nonce if only 15 are used?</summary>
Deoxys‑II defines a 120‑bit nonce. Generating and storing 32 bytes on-chain reduces bias and gives you room for future derivations, while you still pass only the first 15 bytes to the AEAD.
</details>

<details>
<summary>Is it safe if the ECDH shared key is reused across messages?</summary>
Yes, **as long as each encryption uses a unique nonce**. Still, ephemeral caller keys are recommended; alternatively, derive a per-message key from `(ECDH, nonce)` via a KDF.
</details>
