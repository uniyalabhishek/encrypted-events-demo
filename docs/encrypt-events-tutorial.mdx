---
title: Encrypting Event Payloads on Oasis Sapphire
description: Two practical patterns to keep event contents private while preserving on-chain discoverability.
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!-- markdownlint-disable MD025 MD033 -->

# Encrypting Event Payloads on Sapphire

On Ethereum, **all event data is public**. On Sapphire (confidential EVM), you can keep the **event payload encrypted** while the event itself stays indexable and triggerable.

This guide shows two minimal, production-ready patterns (both are in the example repo):

- **A â€” Pass a key in the (encrypted) tx** *(default)*:
  Generate a 32â€‘byte symmetric key offâ€‘chain, pass it to the contract **via an encrypted transaction**, and the contract emits ciphertext.

- **B â€” Derive the key onâ€‘chain (ECDH)** *(alternate)*:
  Exchange Curve25519 public keys, derive a session key onâ€‘chain via X25519, then emit ciphertext.

> â±ï¸ **10 minutes** Â· ğŸ§° Node 18+, Docker (Localnet), Git Â· ğŸ§ª The repo also includes unit tests and a oneâ€‘shot E2E script.

---

## Why encrypt event payloads?

Sapphire can fully hide **calldata** and **state**, but **logs are public by design** so indexers and infra can function. Encrypting just the **payload** gives you:

- âœ… **Searchable/triggerable** events (by topics)
- âœ… **Confidential** contents (ciphertext in `data`)
- âœ… Minimal onâ€‘chain footprint (emit only what you need)

---

## Quick Start

```bash title="Prerequisites"
# Node 18+, Docker (for Localnet), Git
````

### Clone & Install

```bash
git clone https://github.com/oasisprotocol/encrypted-events-demo.git
cd encrypted-events-demo
npm install
```

### Start Sapphire Localnet

```bash
docker run -it -p8544:8544 -p8545:8545 -p8546:8546 ghcr.io/oasisprotocol/sapphire-localnet
# On Apple Silicon, add: --platform linux/amd64  (if the image lacks arm64)
```

---

## Run the Demo

<Tabs>
  <TabItem value="a" label="A â€” Key in the tx (default)" default>

The Hardhat Sapphire plugin **encrypts transactions/calls automatically** on Sapphire networks, so passing a raw key in calldata is safe.

```bash
# 1) Deploy the simple variant
npx hardhat deploy --network sapphire_localnet
# copy the printed address to $ADDR

# 2) Emit an encrypted event (prints the symmetric key)
npx hardhat emit --network sapphire_localnet \
  --contract $ADDR --message "secret ğŸš€"
# âš ï¸ **DEMO ONLY: Do NOT log secret keys in production.**

# 3) Decrypt a past tx by hash
npx hardhat decrypt --network sapphire_localnet \
  --tx <TX_HASH> --key <PRINTED_KEY>

# 4) ğŸ”Š  Live: listen & decrypt as events arrive
npx hardhat listen --network sapphire_localnet \
  --contract $ADDR --key <PRINTED_KEY>
```

  </TabItem>
  <TabItem value="b" label="B â€” Onâ€‘chain ECDH (alternate)">

```bash
# 1) Deploy the ECDH variant (prints the contractâ€™s Curve25519 public key)
npx hardhat deploy-ecdh --network sapphire_localnet
# copy the printed address to $ADDR

# 2) Emit (generates a fresh caller Curve25519 keypair â€” DEMO prints the SECRET)
npx hardhat emit-ecdh --network sapphire_localnet \
  --contract $ADDR --message "secret ğŸš€"
# âš ï¸ **DEMO ONLY: Do NOT log secret keys in production.**

# 3) ğŸ”Š  Live: listen & decrypt (derives the same shared key from $SK)
npx hardhat listen-ecdh --network sapphire_localnet \
  --contract $ADDR --secret <CALLER_SECRET_HEX>
```

  </TabItem>
</Tabs>

---

## How it works (at a glance)

| Piece                 | Code (on-chain) / Library (off-chain)                       |
| --------------------- | ----------------------------------------------------------- |
| **Nonce**             | `bytes32 n = bytes32(Sapphire.randomBytes(32, ""));`        |
| **Encrypt**           | `bytes c = Sapphire.encrypt(key, n, bytes(message), aad);` |
| **Emit**              | `emit Encrypted(n, c);`                                     |
| **Decrypt offâ€‘chain** | `@oasisprotocol/deoxysii` (`AEAD`, `NonceSize = 15`)        |

> **Nonce size:** Deoxysâ€‘II uses a **120â€‘bit (15 bytes)** nonce. We store 32 bytes on chain and use only the first 15 bytes during decryption.

### Key handling patterns

- **Default (wrapperâ€‘encrypted tx):** Provide `bytes32 key` in calldata. Safe because the Sapphire Hardhat plugin **encrypts transactions** on Sapphire networks.
- **ECDH onâ€‘chain:** The contract holds a Curve25519 **secret key** in encrypted state, the caller sends a **public key**; both sides derive the same 32â€‘byte key via X25519.

```sol title="ECDH-style symmetric key derivation on-chain"
(Sapphire.Curve25519PublicKey pk, Sapphire.Curve25519SecretKey sk) =
  Sapphire.generateCurve25519KeyPair("");
bytes32 key = Sapphire.deriveSymmetricKey(callerPublicKey, sk);
```

### Bind ciphertexts with AAD (recommended)

AAD prevents accepting ciphertexts out of context. Bind to `msg.sender`:

```sol title="Solidity: include AAD"
bytes32 nonce = bytes32(Sapphire.randomBytes(32, ""));
bytes memory aad = abi.encodePacked(msg.sender); // 20 bytes
bytes memory cipher = Sapphire.encrypt(key, nonce, abi.encode(message), aad);
emit Encrypted(nonce, cipher);
```

```ts title="TypeScript: use the same AAD when decrypting"
const aad = ethers.getBytes(tx.from);   // 20 bytes to match abi.encodePacked(address)
const plain = aead.decrypt(
  ethers.getBytes(nonce).slice(0, NonceSize),   // first 15 bytes
  ethers.getBytes(ciphertext),
  aad
);
```

---

## ROFL integration (pattern)

A ROFL container can subscribe to your contractâ€™s `Encrypted` events, then decrypt:

1. **Subscribe** by contract and event signature.
2. **Derive the key**:

   - Pattern **A**: retrieve the symmetric key out of band (e.g., injected secret corresponding to the submitter).
   - Pattern **B**: compute `x25519.scalarMult(callerSecret, contractPublic)` using the **callerâ€™s secret** provided to the container.
3. **Fetch AAD** (if used): for `msg.sender`, read `tx.from` for the eventâ€™s `transactionHash`.
4. **Decrypt** with Deoxysâ€‘II (`Nonce = first 15 bytes of the stored 32â€‘byte nonce`).
5. **Act** on the plaintext (no extra storage read necessary).

> Keep the event payload **small** (e.g., an envelope or offâ€‘chain reference) to minimize gas.

---

## Best practices

- **Never reuse `(key, nonce)`**. Always randomize `nonce`.
- Prefer **AAD** (e.g., `msg.sender`) to bind context.
- For ECDH, prefer **ephemeral caller keys** to reduce linkability.
- **Do not log secrets** (symmetric keys or Curve25519 secrets) in production.
- **Events are permanent**â€”emit only what you can keep confidential longâ€‘term.
- **Testnet is not production**; confidentiality is not guaranteed there.
- Consider indexing the `bytes32 nonce` in the event for more efficient filters.

---

## Testnet / Mainnet

```bash
cp .env.example .env      # paste your 0xâ€‘prefixed private key
npx hardhat deploy --network sapphire_testnet
npx hardhat deploy-ecdh --network sapphire_testnet
# Use the same emit/listen/decrypt tasks as on Localnet
```

---

## FAQ

<details>
<summary>Can I decrypt logs as they arrive?</summary>
Yes. Use `npx hardhat listen â€¦` (wrapper) or `npx hardhat listen-ecdh â€¦` (ECDH). For historical scans, you can query past logs and decrypt each event similarly.
</details>

<details>
<summary>Why store 32 bytes of nonce if only 15 are used?</summary>
Deoxysâ€‘II defines a 120â€‘bit nonce. Generating and storing 32 bytes on-chain reduces bias and gives you room for future derivations, while you still pass only the first 15 bytes to the AEAD.
</details>

<details>
<summary>Is it safe if the ECDH shared key is reused across messages?</summary>
Yes, **as long as each encryption uses a unique nonce**. Still, ephemeral caller keys are recommended; alternatively, derive a per-message key from `(ECDH, nonce)` via a KDF.
</details>
