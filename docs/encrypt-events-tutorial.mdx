---
title: Encrypting Events
description: Stepâ€‘byâ€‘step guide to emitting confidential events on OasisÂ Sapphire
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# TutorialÂ Â· Encrypting Events on Sapphire

In Ethereum every log is public. With Sapphire you can **encrypt the *data*
while keeping the *event* indexable**. This tutorial walks through the minimal
pattern implemented in [`encrypted-events-demo`](https://github.com/oasisprotocol/encrypted-events-demo).

:::info Completion time
10Â minutes
:::

## 1Â Â Why encrypt eventsÂ ?

Contract state and calldata can be hidden on Sapphire, but *events* are stored
verbatim so that block explorers and offâ€‘chain services can index them. By
encrypting the payload you get the best of both worlds: searchable logs +
private data.

## 2Â Â Setâ€‘up

```bash title="Prerequisites"
# NodeÂ 18â€¯+, Docker (for Localnet), Git
````

\###Â Clone & Install

```bash
git clone https://github.com/oasisprotocol/encrypted-events-demo.git
cd encrypted-events-demo
npm install
```

\###Â Start Localnet

```bash
docker run -it -p8544-8548:8544-8548 ghcr.io/oasisprotocol/sapphire-localnet
```

## 3Â Â Run the demo

* Copy `.env.example` â†’ `.env` and paste a private key from the locally running localnet.

```bash
npx hardhat deploy  --network sapphire_localnet
npx hardhat emit    --network sapphire_localnet \
  --contract <ADDR> --message "secret ğŸš€"

# Decrypt a past tx
npx hardhat decrypt --network sapphire_localnet \
  --tx <TX_HASH> --key <PRINTED_KEY>

# ğŸ”Š  Live: listen & decrypt as events arrive
npx hardhat listen  --network sapphire_localnet \
  --contract <ADDR> --key <PRINTED_KEY>
```

## 4Â Â Deep dive

| Piece                 | Code                                                                  |
| --------------------- | --------------------------------------------------------------------- |
| **Nonce**Â \*          | `bytes32 nonce = bytes32(Sapphire.randomBytes(32,""));`               |
| **Encrypt**           | `bytes memory c = Sapphire.encrypt(key, nonce, abi.encode(msg), "");` |
| **Emit**              | `emit Encrypted(nonce, c);`                                           |
| **Decrypt offâ€‘chain** | Deoxysâ€‘II (`@oasisprotocol/deoxysii`)                                 |

> \* **Nonce length:** Deoxysâ€‘II uses the *firstÂ 15Â bytes* of the 32â€‘byte
> `nonce`. Generating 32 bytes onâ€‘chain is still recommended to minimise bias.

\###Â Keyâ€‘handling patterns

* **Demo** â€“ pass raw `bytes32 key` in the tx (âš ï¸Â revealed if the tx is **not** encrypted).
* **Production** â€“ derive onâ€‘chain **inside** the contract *or* encrypt the
  transaction with the [`@oasisprotocol/sapphire-paratime`](https://www.npmjs.com/package/@oasisprotocol/sapphire-paratime) wrapper.

```sol title="Deriving a symmetric key in Solidity"
bytes32 key = Sapphire.deriveSymmetricKey(
    "",                       // context (optional salt)
    abi.encodePacked(msg.sender) // perâ€‘user derivation
);
```

## 5Â Â Security best practices

* Never reuse the same **`(key, nonce)` pair**.
* Include **associated data** (e.g. `msg.sender`) in both `encrypt` and
  `decrypt` to guarantee authenticity.
* Events stay forever, so avoid putting secrets that will matter in 10Â years.

## 6Â Â Try it on Testnet

```bash
cp .env.example .env      # paste your 0xâ€‘prefixed private key
npx hardhat deploy --network sapphire_testnet
```

Use the same `emit`, `listen`, and `decrypt` tasks.

## 7Â Â FAQ

<details>
<summary>Can I listen to encrypted logs in real timeÂ ?</summary>

Yes. Run `npx hardhat listen â€¦` or subscribe manually:

```ts title="Quick listener"
const filter = contract.filters.Encrypted();
provider.on(filter, (log) => {
  /* parse â†’ decrypt â†’ act */
});
```

ROFL containers typically run a WebSocket listener exactly like this and decrypt
each event on the fly before calling private getter functions.

</details>

<details>
<summary>Why 15Â bytes of nonce when we stored 32Â ?</summary>

Deoxysâ€‘II is defined with a 120â€‘bit nonce. The extra bytes provide entropy
without harming compatibilityâ€”think of them as "futureâ€‘proof padding".

</details>
