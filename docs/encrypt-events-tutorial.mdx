---
title: Encrypting Event Payloads on Oasis Sapphire
description: Two practical patterns to keep event contents private while preserving on-chain discoverability.
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!-- markdownlint-disable MD025 MD033 -->

# Encrypting Event Payloads on Sapphire

On Ethereum, **all event data is public**. On Sapphire (confidential EVM), you can keep the **event payload encrypted** while the event itself stays indexable and triggerable.

This guide shows two minimal, production-ready patterns (both are in the example repo):

* **A — Pass a key in the (encrypted) tx** (default):
    Generate a 32‑byte symmetric key off‑chain, pass it to the contract **via an encrypted transaction**, and the contract emits ciphertext.

* **B — Derive the key on‑chain (ECDH)** (advanced):
    Exchange Curve25519 public keys, derive a session key on‑chain via X25519, then emit ciphertext.

> 10 minutes · Node 18+, Docker (Localnet), Git · Includes unit tests.
> Testnet is not production. Confidentiality is not guaranteed on Testnet. Use Localnet for development and Sapphire Mainnet for production.

---

## Why encrypt event payloads?

Sapphire can fully hide **calldata** and **state**, but **logs are public by design** so indexers and infra can function. Encrypting just the **payload** gives you:

* **Searchable/triggerable** events (by topics)
* **Confidential** contents (ciphertext in `data`)
* **Minimal** on‑chain footprint (emit only what you need)

---

## Quick Start

```bash title="Prerequisites"
# Node 18+, Docker (for Localnet), Git
```

### Clone & Install

```bash
git clone https://github.com/oasisprotocol/encrypted-events-demo.git
cd encrypted-events-demo
npm install

# (Optional) Generate TypeChain types for nicer overloads:
npm run build:types
```

### Start Sapphire Localnet

```bash
docker run -it -p8544-8548:8544-8548 ghcr.io/oasisprotocol/sapphire-localnet
# On Apple Silicon, add: --platform linux/x86_64  (if the image lacks arm64)
```

---

## Run the Demo

<Tabs>
  <TabItem value="a" label="A — Key in the tx (default)" default>

> Only on Sapphire. Passing a raw key in calldata is safe only on Sapphire networks because the Sapphire wrappers encrypt calls/transactions. Do not use this pattern on non-Sapphire chains.

```bash
# 1) Deploy the simple variant
npx hardhat deploy --network sapphire-localnet
# copy the printed address to $ADDR (this is the CONTRACT address, not a tx hash)

# 2) Emit an encrypted event (prints the symmetric key)
#    Choose AAD mode: none (default), sender, or context.
npx hardhat enc --network sapphire-localnet \
  --action emit --mode key --contract $ADDR \
  --message "secret" [--key <HEX32>] [--aadmode sender|context]
# **DEMO ONLY:** Do NOT log secret keys in production.

# 3) Decrypt a past tx by hash
#    (In key mode, --contract is optional; pass it to disambiguate if the tx has multiple logs.)
npx hardhat enc --network sapphire-localnet \
  --action decrypt --mode key [--contract $ADDR] \
  --tx <TX_HASH> --key <PRINTED_OR_PROVIDED_KEY> [--aadmode sender|context]

# 4) Live: listen and decrypt as events arrive (stays open until Ctrl-C)
npx hardhat enc --network sapphire-localnet \
  --action listen --mode key --contract $ADDR \
  --key <PRINTED_OR_PROVIDED_KEY> [--aadmode sender|context]
```

  </TabItem>
  <TabItem value="b" label="B — On‑chain ECDH (advanced)">

```bash
# 1) Deploy the ECDH variant (prints the contract’s Curve25519 public key, bytes32)
npx hardhat deploy-ecdh --network sapphire-localnet
# copy the printed address to $ADDR

# 2) Emit
#    Tip: provide --secret to reuse the same caller secret across emit & listen.
#    Choose AAD mode: none (default), sender, or context.
npx hardhat enc --network sapphire-localnet \
  --action emit --mode ecdh --contract $ADDR \
  --message "secret" [--secret <HEX32>] [--aadmode sender|context]
# **DEMO ONLY:** Do NOT log secret keys in production.

# 3) Live: listen and decrypt (derives the same shared key from --secret)
#    Optional: --hkdf derives a per-message key off-chain (contract must also use HKDF on-chain).
npx hardhat enc --network sapphire-localnet \
  --action listen --mode ecdh --contract $ADDR \
  --secret <HEX32> [--aadmode sender|context] [--hkdf]

# 4) Decrypt a past tx by hash (ECDH — needs the contract to fetch its public key)
npx hardhat enc --network sapphire-localnet \
  --action decrypt --mode ecdh --contract $ADDR \
  --tx <TX_HASH> --secret <HEX32> [--aadmode sender|context] [--hkdf]
```

  </TabItem>
</Tabs>

> **Tip:** With TypeChain/ethers v6 **typed filters**, the listener receives the **non‑indexed args** plus the event object — here `(nonce, ciphertext, event)`. Read the indexed `sender` from `event.args.sender` when using `--aadmode sender`.

---

## How it works (at a glance)

| Piece                 | Code (on-chain) / Library (off-chain)                                            |
| --------------------- | -------------------------------------------------------------------------------- |
| **Nonce**             | `bytes32 n = bytes32(Sapphire.randomBytes(32, bytes("EncryptedEvents:nonce")));` |
| **Encrypt**           | `bytes c = Sapphire.encrypt(key, n, message, aad);` *(message is `bytes`)*       |
| **Emit**              | `emit Encrypted(msg.sender, n, c);`                                              |
| **Decrypt off‑chain** | `@oasisprotocol/deoxysii` (`AEAD`, `NonceSize = 15`)                             |

> **Nonce size:** Deoxys‑II uses a **120‑bit (15 bytes)** nonce. We store 32 bytes on chain and use only the first 15 bytes during decryption.
> **Gas note:** If you emit a **non‑indexed** `bytes15 nonce` instead of `bytes32`, you save \~136 gas per event (17 bytes × 8 gas/byte for log data). We keep `bytes32` for simplicity and future derivations; topic cost is per topic, not per type size.

### Key handling patterns

* **Default (wrapper‑encrypted tx):** Provide `bytes32 key` in calldata. Safe because the Sapphire Hardhat plugin **encrypts transactions** on Sapphire networks.
* **ECDH on‑chain:** The contract holds a Curve25519 **secret key** in encrypted state, the caller sends a **public key**; both sides derive the same 32‑byte key via X25519.

```sol title="ECDH-style symmetric key derivation on-chain"
(Sapphire.Curve25519PublicKey pk, Sapphire.Curve25519SecretKey sk) =
  Sapphire.generateCurve25519KeyPair("");
bytes32 key = Sapphire.deriveSymmetricKey(callerPublicKey, sk);
```

> Note (ECDH): Off‑chain, derive the Deoxys‑II key from the caller’s X25519 secret and the contract’s public key using the **official SDK helper**:
>
> ```ts
> import { mraeDeoxysii } from '@oasisprotocol/client-rt';
> const key = mraeDeoxysii.deriveSymmetricKey(contractPublic, callerSecret);
> const aead = new AEAD(key);
> ```
>
> This mirrors Sapphire’s on‑chain derivation.

### Bind ciphertexts with AAD (recommended)

AAD prevents accepting ciphertexts out of context. **Pick one option below and be consistent** across emit/decrypt:

| Option                                   | Solidity (on‑chain AAD)                          | Off‑chain AAD bytes                                                         |
| ---------------------------------------- | ------------------------------------------------ | --------------------------------------------------------------------------- |
| **A — Sender‑bound** (relayer‑aware)     | `abi.encodePacked(msg.sender)`                   | Use the **emitted `sender`** (first event arg) as bytes (20 bytes)          |
| **B — Context‑bound** (relayer‑agnostic) | `abi.encodePacked(block.chainid, address(this))` | `ethers.solidityPacked(["uint256","address"], [chainId, CONTRACT_ADDRESS])` |

```sol title="Solidity: include AAD and emit sender"
bytes32 nonce = bytes32(Sapphire.randomBytes(32, bytes("EncryptedEvents:nonce")));
bytes memory aad = abi.encodePacked(msg.sender); // Option A
bytes memory cipher = Sapphire.encrypt(key, nonce, message, aad);
emit Encrypted(msg.sender, nonce, cipher);
```

```ts title="TypeScript: use the emitted sender as AAD"
const sender: string = ev.args[0]; // from the Encrypted event
const aad = ethers.getBytes(sender); // 20 bytes to match abi.encodePacked(address)
const plain = aead.decrypt(
  ethers.getBytes(nonce).slice(0, NonceSize),   // first 15 bytes
  ethers.getBytes(ciphertext),
  aad
);
```

#### AAD caveat: relayers, forwarders & gasless/meta‑tx

`msg.sender` (on‑chain) can differ from `tx.from` when using relayers/forwarders (e.g., EIP‑2771) or meta‑transactions. **Emitting `sender`** in the event avoids ambiguity: the exact value used for on‑chain AAD is available off‑chain. In meta‑tx flows, the "signer" visible off‑chain may differ—**`msg.sender` is the on‑chain source of truth**.

---

## (Optional) Per‑message KDF: HKDF(ECDH, nonce)

For better unlinkability, derive a per‑message AEAD key from the **ECDH shared key** and the **nonce** (first 15 bytes). Example using Node’s `crypto.hkdfSync`:

```ts
import { hkdfSync } from "crypto";
import { NonceSize } from "@oasisprotocol/deoxysii";

// ecdhKey: Uint8Array(32) from mraeDeoxysii.deriveSymmetricKey
// nonce32: 0x-prefixed hex from event; use first 15 bytes
const salt = ethers.getBytes(nonce32).slice(0, NonceSize);
const info = Buffer.from("sapphire:events");
const sessionKey = hkdfSync("sha256", Buffer.from(ecdhKey), salt, info, 32);
// then: const aead = new AEAD(sessionKey);
```

> Keep both sides (emitter and decryptor) consistent about this KDF. **The demo contracts do not apply HKDF on‑chain**; `--hkdf` in the CLI is provided for advanced variants.

---

## ROFL integration (pattern)

A ROFL container can subscribe to your contract’s `Encrypted` events, then decrypt:

1. **Subscribe** by contract and event signature.
2. **Derive the key**:
    * Pattern **A**: retrieve the symmetric key out of band (e.g., injected secret corresponding to the submitter).
    * Pattern **B**: compute the same key as on‑chain via `mraeDeoxysii.deriveSymmetricKey(contractPublic, callerSecret)`.
3. **Build AAD**: use **sender** (Option A) or **context** (Option B) to match the contract side.
4. **Decrypt** with Deoxys‑II (`Nonce = first 15 bytes of the stored 32‑byte nonce`).
5. **Act** on the plaintext (no extra storage read necessary).

> Keep the event payload **small** (e.g., an envelope or off‑chain reference) to minimize gas.

---

## Best practices

* **Never reuse `(key, nonce)`**. Always randomize `nonce`.
* Prefer **AAD** for authenticity; `sender` is relayer‑aware; `context` is relayer‑agnostic.
* For ECDH, prefer **ephemeral caller keys** to reduce linkability (or derive per‑message keys from `(ECDH, nonce)` via a KDF).
* **Do not log secrets** (symmetric keys or Curve25519 secrets) in production.
* **Events are permanent**—emit only what you can keep confidential long‑term.
* **Testnet is not production**; confidentiality is not guaranteed there.
* **Index wisely.** Indexing a *random nonce* is rarely useful and costs a topic; indexing `sender` is typically more useful. Changing `bytes32 → bytes15` does **not** reduce topic cost when indexed (topics are a flat cost).
* **Length leaks size.** If sensitive, **pad** plaintext client‑side to fixed buckets before encrypting.
* **Pass the right parameter.** `--contract` must be the **contract address** (0x…) for all commands except `decrypt --mode key`, where it is optional.

---

## Testnet / Mainnet

```bash
cp .env.example .env      # paste your 0x‑prefixed private key
npx hardhat deploy --network sapphire-testnet
npx hardhat deploy-ecdh --network sapphire-testnet
# Use the same enc commands as on Localnet
```

---

## Unified CLI

> **Heads up:** `--contract` expects a **contract address** (0x…) for *all* commands except `decrypt --mode key` where it is optional. It is **not** a transaction hash.

```bash
# Emit with a key
npx hardhat enc --network sapphire-localnet --action emit --mode key  --contract $ADDR --message "secret" [--key <HEX32>] [--aadmode sender|context]

# Emit with ECDH (prints caller SECRET for demo)
npx hardhat enc --network sapphire-localnet --action emit --mode ecdh --contract $ADDR --message "secret" [--secret <HEX32>] [--aadmode sender|context]

# Listen with a key
npx hardhat enc --network sapphire-localnet --action listen --mode key  --contract $ADDR --key <HEX32> [--aadmode sender|context]

# Listen with ECDH (needs caller SECRET)
npx hardhat enc --network sapphire-localnet --action listen --mode ecdh --contract $ADDR --secret <HEX32> [--aadmode sender|context] [--hkdf]

# Decrypt a past tx (key) – contract optional
npx hardhat enc --network sapphire-localnet --action decrypt --mode key  [--contract $ADDR] --tx <TX_HASH> --key <HEX32> [--aadmode sender|context]

# Decrypt a past tx (ECDH) – contract required
npx hardhat enc --network sapphire-localnet --action decrypt --mode ecdh --contract $ADDR --tx <TX_HASH> --secret <HEX32> [--aadmode sender|context] [--hkdf]
```

---
