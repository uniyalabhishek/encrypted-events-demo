---
title: Encrypting Events on Sapphire
description: Step-by-step guide to emitting confidential events and decrypting them off-chain
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!-- markdownlint-disable MD025 MD033 -->

## Encrypting Events on Sapphire

On Ethereum, **events are public**. On Sapphire, you can **encrypt the event payload** while keeping the event itself indexable. This guide shows two minimal patterns (both included in the example repo):

- **A — Pass a key in the (encrypted) tx:** generate a symmetric key off‑chain, pass it to the contract (safe when the tx is encrypted), then emit ciphertext.
- **B — Derive the key on‑chain (ECDH):** exchange Curve25519 keys, derive a session key via X25519 on-chain, then emit ciphertext.

> ⏱️ **10 minutes**

---

### 1) Why encrypt events?

Sapphire can hide calldata and state, but **logs remain public by design** so indexers can operate. Encrypting the log payload gives you **searchable events + private content**.

---

### 2) Setup

```bash title="Prerequisites"
# Node 18+, Docker (for Localnet), Git
````

#### Clone & Install

```bash
git clone https://github.com/oasisprotocol/encrypted-events-demo.git
cd encrypted-events-demo
npm install
```

#### Start Localnet

```bash
docker run -it -p8544:8544 -p8545:8545 -p8546:8546 ghcr.io/oasisprotocol/sapphire-localnet
# Apple Silicon (M‑series): add --platform linux/amd64 if the image lacks arm64
```

---

### 3) Run the demo

<Tabs>
  <TabItem value="a" label="A — Key in the tx (default)" default>

```bash
# 1) Deploy simple variant
npx hardhat deploy --network sapphire_localnet

# 2) Emit an encrypted event (the task prints the symmetric key)
npx hardhat emit --network sapphire_localnet \
  --contract <ADDR> --message "secret 🚀"

# 3) Decrypt a past tx
npx hardhat decrypt --network sapphire_localnet \
  --tx <TX_HASH> --key <PRINTED_KEY>

# 4) 🔊  Live: listen & decrypt as events arrive
npx hardhat listen --network sapphire_localnet \
  --contract <ADDR> --key <PRINTED_KEY>
```

  </TabItem>
  <TabItem value="b" label="B — On‑chain ECDH (alternate)">

```bash
# 1) Deploy ECDH variant (prints contract Curve25519 public key)
npx hardhat deploy-ecdh --network sapphire_localnet

# 2) Emit (generates a caller Curve25519 keypair & prints the SECRET — demo only; do NOT log secrets in production)
npx hardhat emit-ecdh --network sapphire_localnet \
  --contract <ADDR> --message "secret 🚀"

# 3) 🔊  Live: listen & decrypt (uses the printed caller SECRET)
npx hardhat listen-ecdh --network sapphire_localnet \
  --contract <ADDR> --secret <CALLER_SECRET_HEX>
```

  </TabItem>
</Tabs>

---

### 4) Deep dive

| Piece                 | Code                                                                  |
| --------------------- | --------------------------------------------------------------------- |
| **Nonce** \*          | `bytes32 nonce = bytes32(Sapphire.randomBytes(32, ""));`              |
| **Encrypt**           | `bytes memory c = Sapphire.encrypt(key, nonce, abi.encode(msg), "");` |
| **Emit**              | `emit Encrypted(nonce, c);`                                           |
| **Decrypt off‑chain** | Deoxys‑II (`@oasisprotocol/deoxysii`)                                 |

 > - **Nonce length:** **Deoxys‑II uses the first 15 bytes** of the 32‑byte nonce. Generating 32 bytes on‑chain is recommended to minimize bias.

#### Key‑handling patterns

- **Default (this repo):** all tasks run through `@oasisprotocol/sapphire-hardhat`, which **encrypts transactions/calls automatically** on Sapphire networks.
- **Pass a key in the tx (demo A):** provide `bytes32 key` as calldata (safe because the tx itself is encrypted by the wrapper).
- **ECDH on‑chain (demo B):** keep the contract’s Curve25519 **secret key** in encrypted state, accept the caller’s Curve25519 **public key**, and derive a shared key via X25519:

  ```sol title="ECDH-style symmetric key derivation on-chain"
  (Sapphire.Curve25519PublicKey pk, Sapphire.Curve25519SecretKey sk) =
    Sapphire.generateCurve25519KeyPair("");
  bytes32 key = Sapphire.deriveSymmetricKey(callerPublicKey, sk);
  ```

#### Add associated data (recommended)

Bind the ciphertext to `msg.sender` for authenticity:

```sol title="Solidity: include associated data"
bytes32 nonce = bytes32(Sapphire.randomBytes(32, ""));
bytes memory aad = abi.encodePacked(msg.sender); // 20 bytes
bytes memory cipher = Sapphire.encrypt(key, nonce, abi.encode(message), aad);
emit Encrypted(nonce, cipher);
```

```ts title="TypeScript: use the same AAD during decryption"
const aad = ethers.getBytes(tx.from); // 20 bytes
const plain = aead.decrypt(
  ethers.getBytes(nonce).slice(0, NonceSize),
  ethers.getBytes(ciphertext),
  aad
);
```

---

### 5) Security best practices

- **Never reuse** a `(key, nonce)` pair.
- Prefer **AAD** (e.g., `msg.sender`) to bind ciphertexts to callers.
- **Transactions must be encrypted** when passing a raw key via calldata; otherwise use the **ECDH** pattern.
- **Do not log secrets** (symmetric keys or Curve25519 secrets) in production.
- **Events are permanent**—don’t emit data you’ll need to keep secret for years.
- **Testnet is not production**; confidentiality isn’t guaranteed there.

---

### 6) Try it on Testnet

```bash
cp .env.example .env      # paste your 0x‑prefixed private key
npx hardhat deploy --network sapphire_testnet
npx hardhat deploy-ecdh --network sapphire_testnet
# use the same emit/listen/decrypt tasks as Localnet
```

---

### 7) FAQ

<details>
<summary>Can I decrypt logs as they arrive?</summary>
Yes. Use `npx hardhat listen …` (wrapper) or `npx hardhat listen-ecdh …` (ECDH), or subscribe manually with a filter and decrypt each event.
</details>

<details>
<summary>Why 15 bytes of nonce if I stored 32?</summary>
Deoxys‑II defines a **120‑bit nonce**; Sapphire’s `encrypt/decrypt` use the first 15 bytes. The extra bytes offer entropy headroom.
</details>
